$ErrorActionPreference = "Stop"    
Function Stop-ComputerSession {
    Param(
        [Parameter(Mandatory = $False, Position = 0, ValueFromPipeline = $True)]
        [string[]]$Computer,
        [Parameter(Mandatory = $False, Position = 1, ValueFromPipeline = $True)]
        [string]$SessionId      
    )    

    if ($Computer){
    }else{
        $Computer = 'localhost'
    }

    $exitCode = $global:LASTEXITCODE

    ForEach($c in $Computer) {
        $result = &reset session $SessionId /server:$c
    }

    $global:LASTEXITCODE = $exitCode
}

Function Get-ComputerSessions {
[cmdletbinding(
    DefaultParameterSetName = 'session',
    ConfirmImpact = 'low'
)]
    Param(
        [Parameter(
            Mandatory = $False,
            Position = 0,
            ValueFromPipeline = $True)]
            [string[]]$Computer
            )
Begin {
    $report = @()
    }
Process {
    if ($Computer){
    }else{
        $Computer = @('localhost')
    }

    $exitCode = $global:LASTEXITCODE

    ForEach($c in $Computer) {
        # Parse 'query session' and store in $sessions:
        $sessions = &query session /server:$c
        1..($sessions.count -1) | % {
            $temp = "" | Select Computer,SessionName, Username, Id, State, Type, Device
            $temp.Computer = $c
            $temp.SessionName = $sessions[$_].Substring(1,18).Trim()
            $temp.Username = $sessions[$_].Substring(19,20).Trim()
            $temp.Id = $sessions[$_].Substring(39,9).Trim()
            $temp.State = $sessions[$_].Substring(48,8).Trim()
            $temp.Type = $sessions[$_].Substring(56,12).Trim()
            $temp.Device = $sessions[$_].Substring(68).Trim()
            $report += $temp
        }
    }

    $global:LASTEXITCODE = $exitCode
}
End {
    $report
    }
}

Function Invoke-InDesktopSession {
    Param(        
            [string]$username,
            [string]$password,
            [string]$command,
            [string]$psexecPath,
            [string]$rdpplusPath
            )
    
    $domain = ""
    if ($username -match "\\") {
        $domain = $username.split('\\')[0]
        $username = $username.split('\\')[1]
    }

    if ($username -match "@") {
        $domain = $username.split('@')[1]
        $username = $username.split('@')[0]
    }

    $computer = [System.Net.Dns]::GetHostByName($env:Computer).HostName
    $existingSessionForUser = Get-ComputerSessions -computer $computer | ?{$_.Username -eq $username}

    if ($existingSessionForUser) {
        $sessionIdForUser = $existingSessionForUser.Id
    } else {
		echo "$rdpplusPath" /v:$computer /u:$username /p:$password /o:"authentication level:i:0"
        &"$rdpplusPath" /v:$computer /u:$username /p:$password /o:"authentication level:i:0"
        $sessionIdForUser = $null
        while (!$sessionIdForUser) {
            sleep 1
            $sessionIdForUser = Get-ComputerSessions -computer $computer | ?{$_.Username -eq $username} | %{$_.Id} 
        }
    }

    $process = Start-Process -FilePath $psexecPath -ArgumentList "-accepteula -i $sessionIdForUser $command" -NoNewWindow -PassThru -Wait
    $process.WaitForExit()

    if ($existingSessionForUser) {
    } else {
        Stop-ComputerSession -Computer $computer -SessionId $sessionIdForUser
    }
    
    exit $process.ExitCode
}
